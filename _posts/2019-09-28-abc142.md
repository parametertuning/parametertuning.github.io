---
title: ABC142
author: cdddar
---

[atcoder.jp/contests/abc142](https://atcoder.jp/contests/abc142)

## A - Odds of Oddness

偶数ならちょうど `0.5`。
奇数の場合は気をつけて計算すると
`(n - (n / 2)) / n`
になる。
ただし `/ 2` は `int` の計算で、 `/ n` は `float` の計算にすること。

## B - Roller Coaster

問題文を数式にするだけ

## C - Go to School

一瞬問題文の理解に苦しんだけど、要するに $i$ の着順が $A_i$ として与えられているだけ。だから $A_i$ についてソートして $i$ を出力すればいい。
入力 $A_i$ を $(A_i, i)$ というタプルにしておいてソートして $i$ だけ出力する。
（あるいは numpy の `argsort` とか？）

```python
n: int = input()
A: List[int] = input()

arr = [(a, i) for i, a in enumerate(A)]
arr.sort()
print([i for a, i in arr])
```

## D - Disjoint Set of Common Divisors

公約数と言わずにまずは整数 $A$ の約数から互いに素な数をたくさん選ぶことを考える。
いずれも互いに素だということは公約数を持たないということ（それはそう）。

とりあえず素因数分解
$$A = p_1^{a_1} \times p_2^{a_2} \times \cdots \times p_n^{a_n}$$

これの約数として $p_1 \times p_2$ なんかを選んだとする。
そうすると他に選ぶ約数は $p_1$ も $p_2$ も含んではいけないことになる。。。
じゃあ $p_1, p_2, \ldots, p_n$ を（排反に）分配すればいい。
そして出来るだけ多く作りたいのだから、素数単体にすればいい。

$A$ からは
$p_1, p_2, \ldots, p_n$
という最大で $n$ 個の約数を選ぶことができる。
あ、$1$ という約数もある。これはどの素数も選ばない
（$1$ は素因数分解すると $\prod \emptyset$）
ことに相当する。
というわけで $A$ からは
$1, p_1, p_2, \ldots, p_n$
という $n+1$ 個を選べる。

元の問題に戻ると、 $A$ と $B$ の公約数から選ぶ。
最大公約数を素因数分解してそれに含まれる素数の数を数えればいい。
それに $1$ を加えたのが答え。

```python
a: int = input()
b: int = input()
g = gcd(a, b)

# 素因数分解 (何乗かはどうでもいいので捨てる）
primes = set()
for p in range(2, p + 1):
  if g % p == 0:
    primes.add(p)
    while g % p == 0:
      g /= p

  # sqrt(g) まで調べれば十分
  if p * p > g:
    if g > 1:  # 残ったのは素数
      primes.add(g)

# 素数の数 + 1 が答え
print(len(primes) + 1)
```

## E - Get Everything

典型的な bitDP。
ドアの数 $N$ が小さくて $2^N$ も十分小さいのが特徴。

今 $N$ 個のドアの内、どのドアの部分集合を開くことが出来るか、を状態にする。

- ドア集合
  - $D = \{1,2,\ldots,N\}$
- 状態
  - $S \subset D$

$$dp_S = S \text{ を開くのに必要な鍵の最小コスト }$$

$dp_\emptyset = 0$
から初めてよしなにDPする。

## F - Pure

なんやかんや考察すると、結局検出しろといっている部分グラフは余計な枝が生えていない閉路であることが分かる。
余計な枝とは、ただ一周する閉路の中に更に枝が生えているもののこと。

しかし、そのように余計な枝が生えているなら、必ず、さらに小さい閉路がそこにあるはずだ

閉路 $A \to B \to C \to D \to E \to F \to F$ を見つけた。しかしそこに余計な辺
$B \to E$
が生えていた。

```
A -> B -> C
^    v    v
^    v!!  v
^    v    v
F <- E <- D
```

ならば、

```
A -> B
^    v
^    v
^    v
F <- E
```

と、さらに小さい閉路を取れる。

というわけで、最小の長さの閉路を見つければいい。

この問題では頂点数も辺数も小さいので、難しく考えず、各頂点からダイクストラ法を始めた。
もっと正確に言う。
点 $u$ からスタートする閉路を検出する場合、 $u$ の隣接点を探索スタックに積んでおいてダイクストラ法をスタートして、$u$ までの最短路を見つければよい。

ただし $u$ にたどり着かず、変な閉路にハマってしまうのが怖かったので、探索するパスに、頂点数と同じだけの長さの上限を設けた。閉路があるなら頂点数以下の長さでしかないはずなので。

> 書いてて思ったけど、負の長さの辺があるわけじゃないので「閉路にハマる」とかあるわけないですね。
> この上限のキャップは要らないです。

計算量について。
頂点数 $N \leq 1000$ で辺数が $M \leq 2000$ 。
優先度付きキューでダイクストラ法を回せば一回が
$O((N+M) \log N)$ で、これを $N$ 回行うので全体では
$O(N(N+M) \log N)$。

