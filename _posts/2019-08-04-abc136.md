---
title: ABC136
author: cdddar
---

[atcoder.jp/contests/abc136](https://atcoder.jp/contests/abc136)

## A - Transfer

この場にある総量が $B+C$ であって、これを出来るだけ $A$ に入れて残りがいくらあるかと考えれば、答えは $\max(B+C-A, 0)$。

## B - Uneven Numbers

桁数で分別して考えれば正整数というのは

- $r_0 = [1,9]$
- $r_1 = [10,99]$
- $r_2 = [100,999]$
- $r_m = [10^m, 10^{m+1}-1]$

という風に区間 $r_0, r_1, \cdots$ に分割できる
(NOTE: この問題では $0$ は除いてることに注意)。
添字が偶数な区間の中の数はちょうど桁数が奇数 ($r_0, r_2,\cdots$)。

与えられた数 $N$ がどの区間にあるかを判定してやればいい。
$N \in r_m$ だとする。
$N$ 以下で桁数が奇数なものは, まず
$r_0 \cup r_2 \cup \cdots \cup r_m'$
がある。
ここで $m'$ は $m$ 未満の最大の偶数。

それから $m$ が偶数であればこれに
$[10^m, N]$
も加える。

以上の個数を足せば良い。

$N \leq 10^5$ なのでせいぜい $r_4$ までを考えればいい。

## C - Build Stairs

左から見て右は大きくていくらでも大きくて構わない。
だから特に最右端の数は減らすメリットが全く無く、最初に与えられたままの数を使えばよい。
というわけで一番右端の数は確定された。
次に右から二番目の数だが、もし一番右端の数以下であれば、そのままでも単調非減少になってるので放っておいて良い。
なぜならこれも全く同様の理由で大きいに越したことがないから。
逆に減らす必要があるのは一番右端の数より大きい場合だけ。
1減らしても駄目ならもう駄目。

という考察から右端から決めていけばよい。

```python
xs: List[int] = input()
n = len(xs)
for i in reversed(range(n - 1)):
    if xs[i - 1] > xs[i]:
        xs[i - 1] -= 1

if non_negative_ordering(xs):
    print("Yes")
else:
    print("No")
```

## D - Gathering Children

移動の回数は十分に大きいので、大雑把に言えば収束した状態を問うている。
そして収束するような場所というのは

```
....RL....
```

という箇所しかありえない。
左端は必ず `R` で右端は必ず `L` であるという条件もこれに貢献している。

つまり `R` の次は `L` に行き、その次は `R` に戻る、という反復をしている。
なので厳密には収束ではなくて、移動回数の偶奇（パリティ）で移動先は決まる。
上の図で今 `R` にいる人は偶数移動後には `R` にいて、奇数移動後には `L` にいる。

次に

```
..RRRL....
  321
```

という状態の `R3` にいることを考える。
これもやはり `RL` の間で反復するので、このどちらかにいることになる。
そのどちらにいるかはやはりパリティを観ることになるが、その隣の `R2` とちょうど逆になることが簡単に想像つく。
そして `R2` にいる人が行き着く先のパリティは `R1` のちょうど逆になる。

という風に、パリティを気にしながら行き先をシミュレートすれば答えは求まる。

しかし当然、毎回全てシミュレートすると、$O(N^2)$ になるので、各マスからのシミュレートの結果を必ずメモすることにする。
$i$ 番目にいる人をシミュレートするために $i-1$ 番目と $i+1$ 番目のシミュレートを先に行っておけば、$i$ 番目のシミュレートは定数時間で終わる。
なぜなら次のように出来るから

```python
def simulate(i):
    if S[i] == 'L'
        return negate(result_simulate(i - 1))
    elif S[i] == 'R'
        return negate(result_simulate(i + 1))
```

ここで `result_simulate` はシミュレートの結果の参照であって、
`negate` はそのパリティの反転。
（後述する）実際のシミュレート関数では `result_simulate` を再帰にして、適切な基底条件を付け加える。

これを $i=0,1,\ldots,N-1$ について行うから全体としては $O(N)$ で計算終了する。

パリティの反転であるが、（十分大きい）偶数回の移動後の場所のメモと奇数回の移動後の場所のメモの2つを持っておけば、それを入れ替えるだけで出来る。
メモを配列で持っておけば `result_simulate` はその要素アクセスである。

以上から次のようにして解ける。

```python
S: str = input()
N = len(S)

result_even = [None] * N  # result_even[i] は i から始めて十分大きい偶数回の移動後にいる場所のインデックス
result_odd = [None] * N  # 奇数版

def simulate(i):
    if S[i] == 'L'
        if S[i - 1] == 'R':
            result_even[i] = i
            result_odd[i] = i - 1
        else:
            simulate(i - 1)
            result_even[i] = result_odd[i - 1]  # negate!!
            result_odd[i] = result_even[i - 1]
    else:  # 'R'
        if S[i + 1] == 'L':
            result_even[i] = i
            result_odd[i] = i + 1
        else:
            simulate(i + 1)
            result_even[i] = result_odd[i + 1]  # negate!!
            result_odd[i] = result_even[i + 1]

for i in range(N):
    simulate(i)
```

最後は `result_even` を見て結果を集計したら良い。

##  E - Max GCD

この操作で全体の和は変わらない。
それを $S = \sum_i A_i$ とする。
求めたい答え $d$ は全ての $A_i$ の共通の約数だから、したがって $S$ の約数であることが必要条件として得られる。
もちろん逆は成り立たないが、候補にはなる。
すなわち $S$ の約数を大きい方から列挙して、各約数 $d$ について、$K$ 回以下の操作で全ての $A_i$ を $d$ の倍数になるようにできれば $d$ を出力してプログラムを終了したらよい。

> 念の為だが約数 $d=1$ であれば必ずそうできる。

「$K$ 回以下の操作で全ての $A_i$ を $d$ の倍数に出来るか」のチェックは、
「全ての $A_i$ を $d$ の倍数にするために必要な最小の操作回数」が求まれば、それが $K$ 以下で出来るかを調べたらよい。

> 念の為だが、$K$ が十分に大きければ必ずそう出来る。
> なぜなら $i \ne 1$ について $A_i$ を $d$ の倍数になるまで増やして $A_1$ を減らせば、最終的に $A_1$ は必ず $d$ の倍数になってるから。

その最小の操作回数は、、、分からない。
解説の通りにやれば出来たけど、なぜ剰余でソートして2つに分けたら出来るのか？
