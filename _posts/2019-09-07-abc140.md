---
title: ABC140
author: cdddar
---

[atcoder.jp/contests/abc140](https://atcoder.jp/contests/abc140)

## A - Password

```python
n: int = input()
print(n * n * n)
```

## B - Buffet

書いてあることを素直にシミュレーションするプログラムを書く

## C - Maximal Value

逆算すると
$A_i = \min(B_{i-1}, B_i)$
とすればいい。
境界だけが特別だけど、$B$ の両端に余分に $\infty$ を付け足せばいい（$B_0 = B_n = \infty$）。

## D - Face Produces Unhappiness

初めに与えられた文字列について、
連続して並んでる `L` （あるいは `R`）は、最初から一つのグループにくっつけておいていい。
例えば `LLL` と並んでるものを途中で `LRR` みたいに二色にしてしまう必要がない。
反転するときは皆一緒で良い。

また、最終的な答えは結局、連続して並んでる区間 $-1$ の和である。
これは次のようにもう少し簡単に言い直せる。

連続して並んでる区間を全てさっき言ったようにグルーピングする。

```
LLRLLRRR
=>
[L][R][L][R]
```

この例だとグループは4つ。
すると、さっきの $-1$ する回数はグループの回数である。
だから、グループが $g$ 個あるなら、このときの幸福な人数は $N-g$ になる。ただし $N$ は最初の文字列の長さのこと。

それからちょっと考えると、一回の操作ではグループの個数を 2 減らせることと、1 より小さく出来ないことが分かる。
従って、初め $g$ グループあったら $\max(1, g - 2k)$ が答えになる。

## E - Second Sum

$\{1,2,\ldots,N\}$ の順列 $P$ が与えられる。
閉区間 $[i,j]$ について $P_i, P_{i+1},\ldots, P_{j}$ の中で **二番目に** 大きい値を $X_{i,j}$ とする。
全ての区間についてのこの和
$$\sum_{i,j} X_{i,j}$$
を求めよ。

もちろん全ての区間について素朴に計算すると $O(N^2)$ 掛かるが今 $N \sim 10^5$ 程度なので駄目。
逆算すれば $O(N \log N)$ くらいが求められている。

求めたい値は区間に関しての和だけど、逆に、各 $P_i$ について、それが二番目に大きくあるような区間を計算してもいい。
各 $P_i$ に対してそのような区間が $C_i$ 個あるとすれば、
$$\sum_i C_i \times P_i$$
だと言える。
もちろん $\sum_i C_i = N(N-1)/2$ であるべき。

さてそのような区間は RMQ を使えば頑張って計算できる。
もし問題が **一番に** 大きい値についてであれば、もっと簡単だけど、二番目に、なのでただただ面倒臭い。
でも頑張れば出来る。

各 $m = P_i$ に注目してその周辺で

```
[m より大きい] (... m より小さいゾーン ...) [m より大きい] (... 小さいゾーン ...) [m] (... 小さいゾーン ...) [m より大きい] (... 小さいゾーン ...)
```

こんな感じにすれば、そのゾーンの大きさでいい感じに計算できるでしょ？
