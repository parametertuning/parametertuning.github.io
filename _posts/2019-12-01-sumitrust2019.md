---
title: 三井住友信託銀行プログラミングコンテスト2019
author: cdddar

---

[atcoder.jp/contests/sumitrust2019](https://atcoder.jp/contests/sumitrust2019)

企業コンテストであるが難易度や構成は普段のABC

# A - November 30

ある日の日付と次の日の日付が与えられるので月を跨いだかどうか判定する問題。

月日のうちの月だけ見て、数字が同じか変わったかを見れば十分。この問題では月を跨いだ時は `1` を、さもなくば `0` を出力せよとある。月を跨いだときに増える月数はちょうど `1` のはずなので、月の差を出力するといい。

```awk
NR == 1 {
  month_today = $1
}
NR == 2 {
  month_tomorrow = $1
}
END {
  print (month_tomorrow - month_today)
}
```

これを短縮して

```awk
{$0=a=$1-a};c++
```

で 15byte

# B - Tax Rate

消費税は 8% で小数点以下は切り捨てられる。
税込価格が与えられるので税抜き価格を求めよという問題。

切り捨てという非連続な操作があるので単純に $100/108$ 倍しただけだと微妙に値がズレる上に、税込価格としてありえない数字もアリ得るので、それも検出しなければいけない。

与えられる価格は 50000 以下なので、税抜き価格もアリ得るとしたら 50000 未満だと言える。全探索すればいい。

```awk
{
  for (i = 1; i < 50000; ++i) {
    x = int(i * 1.08)  # int() は床関数
    if (x == $1) {
      print(i)
      exit
    }
  }
  print(":(")  # 該当する価格が存在しなかった
}
```

# C - 100 to 105

5種類の価格の商品があってちょうど $X$ 円になる組み合わせがあるか検出せよ。

買える商品の数はそれぞれ 1e6 個までであるが、$X$ が 1e5 以下と言っているので、商品数は足りなくなることはないほど十分にあると思えばいい。

次のようなDPを考える。

$$m_i = \begin{cases}
1 && \text{ when } i \text{ 円にする組み合わせが存在する} \\
0 && \text{ otherwise }
\end{cases}$$

これに関する漸化式として
「$m_i = 1$ かつ $p$ 円の商品が存在するなら、$m_{i + p} = 1$」
というのが考えられる。逆にそうでない場合は $m_{i+p}=0$ である。

特別な場合として $m_0=0$ だけ考えればそう。

# D - Lucky PIN

$N$ 桁の数が与えられる。
ここから 3 桁を選び出して部分列を作る（連続してなくていい、元の順序は保たなければならない）。
作れる部分列の種類はいくらか。
もちろん、選ぶ場所が違っていても同じ数字で作った部分列は同じものと見做す。
（例、"1233" から "123" は二通りの作り方があるが同一視される。）

## 方法 1 - 頑張ってDPをする（辛い）

コンテスト中に書いたのはこちらの方法。
後でもっと簡単な方法を述べる。

ただし重複を上手く除くために、「どの数字で終わる部分列」かまでメモする。

私は次の2種類のDPテーブルを用意した。

- 部分列の長さ $\ell \in \{1,2,3\}$、
- 桁の位置 $1 \leq i \leq N$、
- 数字 $c \in \{0,1,\ldots,9\}$ について、
  - $1$ 桁目から $i$ 桁目までで作れる長さ $\ell$ の部分列であって、ちょうど $i$ 桁目で終わっていて、ちょうど数字 $c$ で終わっているものの個数
      - これを $dp_{\ell,i}^c$ と書く

ちょうどなになにで終わっている、というのは色々使い勝手が良い。

それからもう一つは、今のちょうど何桁目で終わっている、という条件を省いたもの。

- $1$ 桁目から $i$ 桁目までで作れる長さ $\ell$ の部分列であって、ちょうど数字 $c$ で終わっているものの個数
    - これを $\overline{dp}_{\ell,i}^c$ と書く

$\ell,c$ について $dp$ が求まったら同じ添字の $\overline{dp}$ は簡単に求まって、

$$\overline{dp}_{\ell,i}^c = \max_{1 \leq j \leq i} dp_{\ell,i}^c$$

である。

$dp$ の更新には $\overline{dp}$ を使う。
簡単な場合として $i$ 桁目の数字が $c$ でない場合は

$$dp_{\ell,i}^c = 0$$

である。

$i$ 桁目が $c$ の時はそれより左までで長さ $\ell-1$ の列にそれを付け足せば何でもいいので

$$dp_{\ell,i}^c = \sum_d \overline{dp}_{\ell-1,i-1}^d$$

仮に右辺を $dp$ 自身で表そうとすると、位置が違ってても同じ数字で終わってたら一方を無視しないといけなくて〜という処理が入って大変。

以上で $dp$ と $\overline{dp}$ とを交互に更新する方法が分かった。

```python
k: List[int] = input()  # 桁の列
N = len(k)

dp[4][N][10] = []  # dp[ell][i][c]
dp2[4][N][10] = []  # 上線の方の dp

for i in range(N):
  for c in range(10):
    dp[0][i][c] = 1
    dp2[0][i][c] = 1

for ell in [1, 2, 3]:
  # update dp
  for i in range(N):
    for c in range(10):
      dp[ell][i][k[i]] += dp2[ell-1][i-1][c]
  # udpate dp2
  for i in range(1, N):
    for c in range(10):
      dp2[ell][i][c] = max(dp2[ell][i - 1][c], dp[ell][i][c])
```

最終的な答えは $\sum_c \overline{dp}_{3,N}^c$。

## 方法 2 - ぶん回す

逆に "1233" から "123" を作れるかどうかをチェックするには前から舐めればいいだけなので $O(N)$ で出来る。

```python
def check(s: str, sub: str) -> bool:
  """s の部分列として sub が出現するか判定"""
  n = len(s)
  m = len(sub)  # 今の場合 3
  i = 0  # index of s
  j = 0  # index of sub
  while i < n and j < m:
    if s[i] == sub[j]:
      j += 1
    i += 1
  return j == m
```

作り得る部分列はちょうど三桁なのでちょうど 1000 通り。
入力の長さ $N$ は $3e4$ 程度なので全体で $3e7$ 回の配列アクセスをすればいい。

```python
n: int = input()
s: str = input()  # 初めから文字列として受け取る
ans = 0
for i in range(1000):
  sub = f"{i:03d}"  # 0埋めで3桁
  if check(s, sub):
    ans += 1
print(ans)
```

# E - Colorful Hats 2

D の DP に比べたらめちゃんこ簡単。

先頭から順に色を決めていけばok。
決めたら今 A,B,C の色がいくつ確定したかだけメモしておく。
次の人が言う数字が $m$ だとする。今確定した色の数の内、例えば A, B が $m$ 個だとする。
じゃあその人は A か B かにする二通りがある。だから答えを二倍する。
さてその人が A にするか B にするかはそれより後ろの人に影響があるか。無い。
なぜなら個数しか見てないので。
それだけ。

```python
n: int = input()
xs: List[int] = input()

ans = 1

colors = [0, 0, 0]
for x in xs:
  m = len(filter(lambda c: c == x, colors))
  ans *= m
  ans %= MOD
  for i in range(3):
    if m == colors[i]:
      colors[i] += 1
      break

print(ans)
```

# F - Interval Running

変化量 $d_1 = T_1 (A_1 - B_1)$ と $d_2 = T_2 (A_2 - B_2)$ だけに注目すればいい。
$d_1$ だけ変化して次に $d_2$ だけ変化するという折れ線グラフを書く。
頑張って割り算したら求まる。

